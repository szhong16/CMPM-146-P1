from heapq import heappop, heappushfrom math import inf, sqrtdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    # extract args    allBoxes = mesh.get('boxes')    print(allBoxes)    adj = mesh.get('adj')    path = []    boxes = {}    # find source and destination boxes    src = find_box(allBoxes, source_point)    print("src:")    print(src)    dst = find_box(allBoxes, destination_point)    print("dst:")    print(dst)    print("source_point, destination_point:")    print(source_point, destination_point)    path.append(src)    came_from = {src : None}    queue = []    queue.append(src)    while queue:        current = queue.pop(0)        print ("current:")        print (current)        if current == dst:            print ("found destination")            break        for next in adj.get(current):            if next not in came_from:                queue.append(next)                came_from[next] = current    # paths = {source_point: []}          # maps cells to previous cells on path    # pathcosts = {source_point: 0}       # maps cells to their pathcosts (found so far)    # queue = []    # heappush(queue, (0, source_point))  # maintain a priority queue of cells    # while queue:    #     priority, cell = heappop(queue)    #     if cell == destination_point:    #         return path_to_cell(cell, paths)    #     # investigate children    #     for (child, step_cost) in mesh(boxes, cell):    #         # calculate cost along this path to child    #         cost_to_child = priority + transition_cost(boxes, cell, child)    #         if child not in pathcosts or cost_to_child < pathcosts[child]:    #             pathcosts[child] = cost_to_child            # update the cost    #             paths[child] = cell                         # set the backpointer    #             heappush(queue, (cost_to_child, child))     # put the child on the priority queue    return path, boxesdef find_box(box_list, point):    for box in box_list:        if (point[0] > box[0] and point[0] < box[1] and            point[1] > box[2] and point[1] < box[3]) :            return boxdef path_to_cell(cell, paths):    if cell == []:        return []    return path_to_cell(paths[cell], paths) + [cell]    return path, boxes.keys()def transition_cost(level, cell, cell2):    distance = sqrt((cell2[0] - cell[0])**2 + (cell2[1] - cell[1])**2)    average_cost = (level['spaces'][cell] + level['spaces'][cell2])/2    return distance * average_cost