from heapq import heappop, heappushfrom math import inf, sqrtdef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: pathway constraints the path adheres to    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}    # extract args    allBoxes = mesh['boxes']    # print(allBoxes)    adj = mesh['adj']    # find source and destination boxes    src = find_box(allBoxes, source_point)    print("src:")    print(src)    dst = find_box(allBoxes, destination_point)    print("dst:")    print(dst)    if dst == None:        print("path not found")        return path, boxes    print("source_point, destination_point:")    print(source_point, destination_point)    path.append(source_point)    # for graph search algorithm    came_from = {src : None}    queue = [] # queue of boxes    heappush(queue, (0, src))    # queue.append(src)    box_path = []    costUntil = dict()    costUntil = {src : 0}    # dictionary that stores (x,y) of each landing point. box : point    detail_points = {src : source_point}    total_path_cost = 0    while queue:        priority, current = heappop(queue)        if current == dst:            boxes = path_to_cell(current, came_from)            cur = source_point            path.append(source_point)            next_point = find_detail_points(current, next, detail_points, source_point, destination_point)            path.append(next_point)            path.append(destination_point)            print ("found it")            return path, boxes        box = mesh['adj'].get(current)        for next in box:            detail_point_cost = find_detail_points(current, next, detail_points, source_point, destination_point)            x1 = (current[0] + current[1]) / 2            y1 = (current[2] + current[3]) / 2            x2 = (next[0] + next[1]) / 2            y2 = (next[2] + next[3]) / 2            new_cost = priority + heuristic(x1, y1, x2, y2)            if next not in costUntil or new_cost < costUntil[next]:                costUntil[next] = new_cost                came_from[next] = current                heappush(queue, (new_cost, next))    # while queue:        # current = queue.pop(0)        # box_path.append(current)        # print ("current:")        # print (current)        # if current == dst:            # print ("found destination")            # break        # for next in adj[current]:            # detail_point_cost = find_detail_points(current, next, detail_points, source_point, destination_point)            # if next not in came_from:                # detail_points[next] = detail_point_cost[0]                # print("detail points: ")                # print(detail_points[next])                # queue.append(next)                # came_from[next] = current    # for key in detail_points:        # path.append(detail_points[key])    # path.append(destination_point)    return path, boxesdef find_box(box_list, point):    for box in box_list:        if (point[0] > box[0] and point[0] < box[1] and            point[1] > box[2] and point[1] < box[3]) :            return boxdef find_detail_points(box_1, box_2, detail_points, source_point, destination_point):    # ranges of next point    x_range = [max(box_1[0], box_2[0]), min(box_1[1], box_2[1])]    y_range = [max(box_1[3], box_2[3]), min(box_1[2], box_2[2])]    # find bxmin, bxmax    if x_range[0] <= x_range[1]:        bxmin = x_range[0]        bxmax = x_range[1]    else:        bxmin = x_range[1]        bxmax = x_range[0]    # find bymin, bymax    if y_range[0] <= y_range[1]:        bymin = y_range[0]        bymax = y_range[1]    else:        bymin = y_range[1]        bymax = y_range[0]    detail_point = (max(bxmin, min(bxmax, source_point[0])), max(bymin, min(bymax,source_point[1])))    cost = euclidean_distance(detail_point, detail_points[box_1]) + euclidean_distance(destination_point, detail_point)    # mid point    # mid_point = [(x_range[0] + x_range[1])/2, (y_range[0] + y_range[1])/2]    # find costs for each range    # a_cost = euclidean_distance((x_range[0], y_range[0]), detail_points[box_1]) + euclidean_distance(destination_point, (x_range[0], y_range[0]))    # b_cost = euclidean_distance((x_range[1], y_range[1]), detail_points[box_1]) + euclidean_distance(destination_point, (x_range[1], y_range[1]))    # mid_cost = euclidean_distance((mid_point[0], mid_point[1]), detail_points[box_1]) + euclidean_distance(destination_point, (mid_point[0], mid_point[1]))    # # find lowest cost    # if a_cost <= b_cost and a_cost <= mid_cost:    #     cost = a_cost    #     detail_point = (x_range[0], y_range[0])    # elif b_cost < a_cost and b_cost < mid_cost:    #     cost = b_cost    #     detail_point = (x_range[1], y_range[1])    # elif mid_cost < a_cost and mid_cost < b_cost:    #     cost = mid_cost    #     detail_point = (mid_point[0], mid_point[1])    return (detail_point, cost)def euclidean_distance(point_1, point_2):    return sqrt((point_1[0] - point_2[0])**2 + (point_1[1] - point_2[1])**2) * 0.5def path_to_cell(cell, paths):    if cell == []:        return []    return path_to_cell(paths[cell], paths) + [cell]    return path, boxes.keys()def transition_cost(level, cell, cell2):    distance = sqrt((cell2[0] - cell[0])**2 + (cell2[1] - cell[1])**2)    average_cost = (level['spaces'][cell] + level['spaces'][cell2])/2    return distance * average_costdef heuristic(x1, y1, x2, y2):    x = abs(x1 - x2)    y = abs(y1 - y2)    num = sqrt(x * x + y * y)    return num